<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Golem Neural Cortex v8.0</title>
    <style>
        body { font-family: monospace; background: #0d1117; color: #c9d1d9; padding: 20px; }
        .status { padding: 10px; border: 1px solid #30363d; margin-bottom: 10px; border-radius: 6px; }
        .log { color: #8b949e; font-size: 0.9em; }
        h1 { color: #58a6ff; }
    </style>
</head>
<body>
    <h1>ğŸ§  Golem Neural Cortex</h1>
    <div id="model-status" class="status">Initializing Neural Network...</div>
    <div id="db-status" class="status">Connecting to Memory Bank...</div>
    <div id="logs" class="log"></div>

    <script type="module">
        // ä½¿ç”¨ CDN è¼‰å…¥ Transformers.js (ç‰ˆæœ¬å›ºå®šä»¥ç¢ºä¿ç©©å®šæ€§)
        import { pipeline, env } from 'https://cdn.jsdelivr.net/npm/@xenova/transformers@2.16.0';

        // è¨­å®šï¼šä¸ä½¿ç”¨æœ¬åœ°å¿«å–æ¨¡å‹æª”æ¡ˆ (ç›´æ¥å¾ CDN æ‹‰å–ï¼Œé¿å… Node.js æª”æ¡ˆç³»çµ±æ¬Šé™å•é¡Œ)
        env.allowLocalModels = false;
        env.useBrowserCache = true;

        let extractor = null;
        let db = null;
        const DB_NAME = 'GolemMemoryDB';
        const STORE_NAME = 'memories';
        const MODEL_NAME = 'Xenova/all-MiniLM-L6-v2'; // è¼•é‡ç´šã€é€Ÿåº¦å¿«ã€æ•ˆæœå¥½çš„ Embedding æ¨¡å‹

        // UI Helper
        const log = (msg) => {
            console.log(`[Cortex] ${msg}`);
            const logDiv = document.getElementById('logs');
            logDiv.innerHTML = `<div>${new Date().toLocaleTimeString()} - ${msg}</div>` + logDiv.innerHTML;
        };

        // 1. åˆå§‹åŒ– AI æ¨¡å‹
        async function initModel() {
            try {
                log(`Loading Model: ${MODEL_NAME}...`);
                // feature-extraction å°ˆé–€ç”¨æ–¼ç”¢ç”Ÿå‘é‡
                extractor = await pipeline('feature-extraction', MODEL_NAME);
                document.getElementById('model-status').innerText = "âœ… Model Active (all-MiniLM-L6-v2)";
                document.getElementById('model-status').style.borderColor = "#238636";
                log("Model Ready.");
            } catch (e) {
                document.getElementById('model-status').innerText = "âŒ Model Failed: " + e.message;
                log("Model Error: " + e.message);
            }
        }

        // 2. åˆå§‹åŒ– IndexedDB
        function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, 1);
                
                request.onupgradeneeded = (e) => {
                    const db = e.target.result;
                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        // å»ºç«‹ Storeï¼Œä½¿ç”¨è‡ªå‹•éå¢ ID
                        db.createObjectStore(STORE_NAME, { keyPath: 'id', autoIncrement: true });
                    }
                };

                request.onsuccess = (e) => {
                    db = e.target.result;
                    document.getElementById('db-status').innerText = "âœ… Memory Bank Connected";
                    document.getElementById('db-status').style.borderColor = "#238636";
                    log("DB Ready.");
                    resolve();
                };

                request.onerror = (e) => {
                    document.getElementById('db-status').innerText = "âŒ DB Error";
                    reject(e);
                };
            });
        }

        // æ•¸å­¸å·¥å…·ï¼šé¤˜å¼¦ç›¸ä¼¼åº¦ (Cosine Similarity)
        // ç”¨ä¾†è¨ˆç®—å…©å€‹å‘é‡ (å…©å¥è©±) çš„ç›¸ä¼¼ç¨‹åº¦
        function cosineSimilarity(vecA, vecB) {
            let dotProduct = 0;
            let normA = 0;
            let normB = 0;
            for (let i = 0; i < vecA.length; i++) {
                dotProduct += vecA[i] * vecB[i];
                normA += vecA[i] * vecA[i];
                normB += vecB[i] * vecB[i];
            }
            return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));
        }

        // ==========================================
        // ğŸš€ é–‹æ”¾çµ¦ Node.js (Puppeteer) å‘¼å«çš„ API
        // ==========================================

        /**
         * å¯«å…¥è¨˜æ†¶
         * @param {string} text - è¦è¨˜ä½çš„æ–‡å­—å…§å®¹
         * @param {object} metadata - é¡å¤–è³‡è¨Š (ä¾‹å¦‚ä¾†æºã€æ™‚é–“ã€æ¨™ç±¤)
         */
        window.addMemory = async (text, metadata = {}) => {
            if (!extractor || !db) return { success: false, error: "System not ready" };
            
            try {
                // 1. è½‰å‘é‡
                const output = await extractor(text, { pooling: 'mean', normalize: true });
                const embedding = Array.from(output.data); // Tensor è½‰ Array

                // 2. å­˜å…¥ DB
                const tx = db.transaction(STORE_NAME, 'readwrite');
                const store = tx.objectStore(STORE_NAME);
                
                const memoryItem = {
                    text: text,
                    embedding: embedding,
                    metadata: metadata,
                    timestamp: Date.now()
                };

                store.add(memoryItem);
                log(`Memorized: "${text.substring(0, 20)}..."`);
                return { success: true };
            } catch (e) {
                return { success: false, error: e.message };
            }
        };

        /**
         * è®€å–/æœå°‹è¨˜æ†¶ (RAG Core)
         * @param {string} text - æŸ¥è©¢èªå¥ (User çš„è¼¸å…¥)
         * @param {number} topK - å›å‚³å‰å¹¾ç­†æœ€ç›¸ä¼¼çš„
         */
        window.queryMemory = async (text, topK = 3) => {
            if (!extractor || !db) return [];

            try {
                // 1. æŠŠæŸ¥è©¢å­—ä¸²ä¹Ÿè½‰æˆå‘é‡
                const output = await extractor(text, { pooling: 'mean', normalize: true });
                const queryVec = Array.from(output.data);

                // 2. è®€å–æ‰€æœ‰è¨˜æ†¶
                // (è¨»ï¼šå°æ–¼å€‹äººç´šåˆ¥çš„è³‡æ–™é‡ï¼Œ< 10è¬ç­†ï¼Œåœ¨ç€è¦½å™¨åšå…¨é‡æƒæé€Ÿåº¦æ˜¯æ¥µå¿«çš„)
                return new Promise((resolve) => {
                    const tx = db.transaction(STORE_NAME, 'readonly');
                    const store = tx.objectStore(STORE_NAME);
                    const request = store.getAll();

                    request.onsuccess = () => {
                        const allMemories = request.result;
                        
                        // 3. è¨ˆç®—åˆ†æ•¸
                        const scored = allMemories.map(mem => ({
                            text: mem.text,
                            metadata: mem.metadata,
                            score: cosineSimilarity(queryVec, mem.embedding)
                        }));

                        // 4. æ’åºèˆ‡éæ¿¾
                        // éæ¿¾æ‰ç›¸ä¼¼åº¦ä½æ–¼ 0.25 çš„é›œè¨Š (é–¾å€¼å¯è‡ªè¡Œèª¿æ•´)
                        scored.sort((a, b) => b.score - a.score);
                        
                        const results = scored
                            .filter(m => m.score > 0.25) 
                            .slice(0, topK);
                        
                        if (results.length > 0) {
                            log(`Recall hit: "${results[0].text.substring(0, 20)}..." (${(results[0].score*100).toFixed(0)}%)`);
                        }
                        
                        resolve(results);
                    };
                });
            } catch (e) {
                log("Query Error: " + e.message);
                return [];
            }
        };

        // å•Ÿå‹•ç¨‹åº
        (async () => {
            await initDB();
            await initModel();
        })();
    </script>
</body>
</html>
